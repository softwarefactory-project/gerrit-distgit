From 7a5acebc0fb96c7ebd454802e73721f3c4832751 Mon Sep 17 00:00:00 2001
From: Tristan Cacqueray <tdecacqu@redhat.com>
Date: Mon, 26 Mar 2018 06:31:30 +0000
Subject: [PATCH] Add InitSFUser method

---
 .../google/gerrit/pgm/init/InitModule.java    |   1 +
 .../google/gerrit/pgm/init/InitSFUser.java    | 182 ++++++++++++++++++
 2 files changed, 183 insertions(+)
 create mode 100644 java/com/google/gerrit/pgm/init/InitSFUser.java

diff --git a/java/com/google/gerrit/pgm/init/InitModule.java b/java/com/google/gerrit/pgm/init/InitModule.java
index f677cebeae..78bcc94a8c 100644
--- a/java/com/google/gerrit/pgm/init/InitModule.java
+++ b/java/com/google/gerrit/pgm/init/InitModule.java
@@ -52,6 +52,7 @@ public class InitModule extends FactoryModule {
     step().to(InitLogging.class);
     step().to(InitIndex.class);
     step().to(InitAuth.class);
+    step().to(InitSFUser.class);
     step().to(InitAdminUser.class);
     step().to(InitLabels.class);
     step().to(InitSendEmail.class);
diff --git a/java/com/google/gerrit/pgm/init/InitSFUser.java b/java/com/google/gerrit/pgm/init/InitSFUser.java
new file mode 100644
index 0000000000..962fac7ce3
--- /dev/null
+++ b/java/com/google/gerrit/pgm/init/InitSFUser.java
@@ -0,0 +1,182 @@
+// Copyright (C) 2018 Red Hat
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.google.gerrit.pgm.init;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import com.google.common.base.Strings;
+import com.google.gerrit.common.data.GroupReference;
+import com.google.gerrit.common.errors.NoSuchGroupException;
+import com.google.gerrit.extensions.client.AuthType;
+import com.google.gerrit.pgm.init.api.AllUsersNameOnInitProvider;
+import com.google.gerrit.pgm.init.api.ConsoleUI;
+import com.google.gerrit.pgm.init.api.InitFlags;
+import com.google.gerrit.pgm.init.api.InitStep;
+import com.google.gerrit.pgm.init.api.SequencesOnInit;
+import com.google.gerrit.reviewdb.client.Account;
+import com.google.gerrit.reviewdb.server.ReviewDb;
+import com.google.gerrit.server.account.AccountSshKey;
+import com.google.gerrit.server.account.AccountState;
+import com.google.gerrit.server.account.externalids.ExternalId;
+import com.google.gerrit.server.config.AllUsersName;
+import com.google.gerrit.server.group.InternalGroup;
+import com.google.gerrit.server.index.account.AccountIndex;
+import com.google.gerrit.server.index.account.AccountIndexCollection;
+import com.google.gerrit.server.index.group.GroupIndex;
+import com.google.gerrit.server.index.group.GroupIndexCollection;
+import com.google.gerrit.server.util.time.TimeUtil;
+import com.google.gwtorm.server.SchemaFactory;
+import com.google.inject.Inject;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import org.apache.commons.validator.routines.EmailValidator;
+
+public class InitSFUser implements InitStep {
+  private final InitFlags flags;
+  private final ConsoleUI ui;
+  private final AllUsersNameOnInitProvider allUsers;
+  private final AccountsOnInit accounts;
+  private final VersionedAuthorizedKeysOnInit.Factory authorizedKeysFactory;
+  private final ExternalIdsOnInit externalIds;
+  private final SequencesOnInit sequencesOnInit;
+  private final GroupsOnInit groupsOnInit;
+  private SchemaFactory<ReviewDb> dbFactory;
+  private AccountIndexCollection accountIndexCollection;
+  private GroupIndexCollection groupIndexCollection;
+
+  @Inject
+  InitSFUser(
+      InitFlags flags,
+      ConsoleUI ui,
+      AllUsersNameOnInitProvider allUsers,
+      AccountsOnInit accounts,
+      VersionedAuthorizedKeysOnInit.Factory authorizedKeysFactory,
+      ExternalIdsOnInit externalIds,
+      SequencesOnInit sequencesOnInit,
+      GroupsOnInit groupsOnInit) {
+    this.flags = flags;
+    this.ui = ui;
+    this.allUsers = allUsers;
+    this.accounts = accounts;
+    this.authorizedKeysFactory = authorizedKeysFactory;
+    this.externalIds = externalIds;
+    this.sequencesOnInit = sequencesOnInit;
+    this.groupsOnInit = groupsOnInit;
+  }
+
+  @Override
+  public void run() {}
+
+  @Inject(optional = true)
+  void set(SchemaFactory<ReviewDb> dbFactory) {
+    this.dbFactory = dbFactory;
+  }
+
+  @Inject
+  void set(AccountIndexCollection accountIndexCollection) {
+    this.accountIndexCollection = accountIndexCollection;
+  }
+
+  @Inject
+  void set(GroupIndexCollection groupIndexCollection) {
+    this.groupIndexCollection = groupIndexCollection;
+  }
+
+
+    @Override
+    public void postRun() throws Exception {
+        String httpPassword = readHttpPassword();
+        if (httpPassword.isEmpty()) {
+            return ;
+        }
+        System.out.println("Creating Admin user");
+        try (ReviewDb db = dbFactory.open()) {
+            if (!accounts.hasAnyAccount()) {
+                Account.Id id = new Account.Id(sequencesOnInit.nextAccountId(db));
+                String username = "admin";
+                String name = "Administrator";
+                AccountSshKey sshKey = readSshKey(id);
+                String email = readEmail();
+
+                List<ExternalId> extIds = new ArrayList<>(2);
+                extIds.add(ExternalId.createUsername(username, id, httpPassword));
+
+                if (email != null) {
+                    extIds.add(ExternalId.createEmail(id, email));
+                }
+                externalIds.insert("Add external IDs for initial admin user", extIds);
+
+                Account a = new Account(id, TimeUtil.nowTs());
+                a.setFullName(name);
+                a.setPreferredEmail(email);
+		accounts.insert(a);
+
+          // Only two groups should exist at this point in time and hence iterating over all of them
+          // is cheap.
+          Optional<GroupReference> adminGroupReference =
+              groupsOnInit
+                  .getAllGroupReferences(db)
+                  .filter(group -> group.getName().equals("Administrators"))
+                  .findAny();
+          if (!adminGroupReference.isPresent()) {
+            throw new NoSuchGroupException("Administrators");
+          }
+          GroupReference adminGroup = adminGroupReference.get();
+          groupsOnInit.addGroupMember(db, adminGroup.getUUID(), a);
+
+          if (sshKey != null) {
+            VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
+            authorizedKeys.addKey(sshKey.sshPublicKey());
+            authorizedKeys.save("Add SSH key for initial admin user\n");
+          }
+
+          AccountState as = AccountState.forAccount(new AllUsersName(allUsers.get()), a, extIds);
+          for (AccountIndex accountIndex : accountIndexCollection.getWriteIndexes()) {
+            accountIndex.replace(as);
+          }
+
+          InternalGroup adminInternalGroup = groupsOnInit.getExistingGroup(db, adminGroup);
+          for (GroupIndex groupIndex : groupIndexCollection.getWriteIndexes()) {
+            groupIndex.replace(adminInternalGroup);
+          }
+
+        }
+      }
+    }
+
+    private String readHttpPassword() throws IOException {
+        Path httpPasswordPath = Paths.get(System.getProperty("user.home"), ".init", "admin_http_password");
+        if (!Files.exists(httpPasswordPath)) {
+            return "";
+        }
+        return new String(Files.readAllBytes(httpPasswordPath), UTF_8).replaceAll("(\\r|\\n)", "");
+    }
+
+    private String readEmail() throws IOException {
+        Path emailPath = Paths.get(System.getProperty("user.home"), ".init", "admin_email");
+        return new String(Files.readAllBytes(emailPath), UTF_8).replaceAll("(\\r|\\n)", "");
+    }
+
+    private AccountSshKey readSshKey(Account.Id id) throws IOException {
+        Path sshKeyPath = Paths.get(System.getProperty("user.home"), ".init", "admin_ssh_key.pub");
+        String content = new String(Files.readAllBytes(sshKeyPath), UTF_8).replaceAll("(\\r|\\n)", "");
+        return AccountSshKey.create(id, 1, content);
+    }
+}
-- 
2.20.1

